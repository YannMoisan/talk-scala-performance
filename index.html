<!DOCTYPE html>
<html>
  <head>
    <title>Title</title>
    <meta charset="utf-8">
    <link rel="stylesheet" type="text/css" href="css/style.css"/>
  </head>
  <body>
    <textarea id="source">

class: center, middle

# Optimizing your Scala code

---

# Memory allocation

> Experience shows that sustained allocation rates of greater than 1 GB/s are
almost always indicative of performance problems that cannot be corrected by
tuning the garbage collector. The only way to improve performance in these cases
is to improve the memory efficiency of the application by refactoring to
eliminate allocation in critical parts of the application.

From [Optimizing Java](https://www.oreilly.com/library/view/optimizing-java), by Benjamin J. Evans, James Gough &amp; Chris Newland

---

# Either.cond

```scala
Either.cond(cond, insertion, left)
```

--

.section[Bad because] `Right(insertion)` is allocated at each call

---

# Either.cond

```scala
case class Insertion (…) {
  val right = Right(insertion)
}

if (cond) insertion.right else Left(left)
```

---

# memory allocation 6

```scala
def withoutCP: BidRequestId =
  BidRequestId(value.stripSuffix("_CP"))
```

--

.section[Bad because] Always an allocation while in 99% of cases the suffix is
not there.

---

# method

```scala
case class Settings(
  billablePriceAmount: Amount100k,
  currency: Currency
) {
  def billablePrice: MoneyIn[currency.type] =
    Money(billablePriceAmount, currency)
  }
```

--

.section[Bad because] Allocate `Money` at each call

---

# for comprehension

```scala
for {
  a <- Some(1)
  b = 2
} yield a
```

--

.section[Bad because] Allocates a `Tuple2`

```scala
Some.apply(1)
  .map { (a: Int) => val b: Int = 2; Tuple2.apply(a, b) }
  .map({ case (a, b) => a })
```

---

# toNel

```scala
list.toNel.map(f).getOrElse(default)
```

--

.section[Bad because] Allocate 2 `Option`s

---

# toNel

.section[Prefer]

```scala
list match {
    case h::t => f(NonEmptyList(h,t))
    case _ => default
```

---

# List.flatMap

```scala
def as : List[A]
def f : A => Option[B]
as.flatMap(f)
```

--

.section[Bad because] implicit conversion from `Option` to `List`

---

# List.flatMap

.section[Prefer]

```scala
as.collect(Function.unlift(f))
```

---

# List.apply

```scala
List(1)
```

--

.section[Bad because] it allocates an array

```scala
object List {
  override def apply[A](xs: A*): List[A] = xs.toList
}
```

```scala
6: iconst_1
7: newarray       int
```

---

# List.apply

.section[Prefer]

```scala
1 :: Nil
```

---

# Types in Java

- primitive types : `int`, `long`, `float`, `double`, `byte`, `char`, `short`, `boolean`
- objects : `java.lang.Object`

int (4 bytes) vs java.lang.Integer (16 bytes)

---

# Types in Java

```java
jshell> var i = 1
i ==> 1

jshell> i.toString()
|  Error:
|  int cannot be dereferenced
|  i.toString()
|  ^--------^
```

---

# Types in Scala

Unified Type System cf: http://ktoso.github.io/scala-types-of-types/#unified-type-system-any-anyref-anyval

![scala types](http://ktoso.github.io/scala-types-of-types/assets/img/scala-types.png)


---

# toString

```scala
1.toString
```

--

.section[Bad because] boxing

```scala
0: iconst_1
1: invokestatic  #20                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
4: invokevirtual #23                 // Method java/lang/Object.toString:()Ljava/lang/String;
```

---

# toString

.section[Prefer] overloaded method `valueOf`

```scala
String.valueOf(1)
```

---

# Generics

```scala
case class Box[A](value: A)
Box(1)
```

```scala
13: iconst_1
14: invokestatic  #41                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
17: invokespecial #45                 // Method $line37/$read$$iw$Box."<init>":(L$line37/$read$$iw;Ljava/lang/Object;)V
```
---

# Generics

```scala
def buffer = collection.mutable.ArrayBuffer[Int]()
def f = buffer += 1
```

```scala
13: iconst_1
14: invokestatic  #39                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
17: invokevirtual #45                 // Method scala/collection/mutable/ArrayBuffer.$plus$eq:(Ljava/lang/Object;)Lscala/collection/mutable/Growable;
```

---

# Diagnose

instances of `java.lang.Long`

---

# case class `hashCode`

```scala
case class Id(value: Long)
Id(1L).hashCode
```

--

.section[Bad because] scalac generates a call to `MurmurHash3.productHash`

```scala
trait Product {
  def productElement(n: Int): Any
}
```

---

# case class `hashCode`

.section[Prefer]

```scala
case class Id(value: Long) {
  override def hashCode(): Int = value.##
}
```

---

# How to avoid boxing

- array : `Array[Int]` uses an `int[]`
- `@specialized`
- value class

---

# Array[Int]

```scala
Array(1,2,3).indexOf(2)
```

--

.section[Bad because] The method `indexOf` on an array of primitives generates boxing of each value.

The array is converted to `ArrayOps` via implicit conversion and at runtime it calls `IndexedSeqOptimized.segmentLength`.

---

# Array[Int]

.section[Prefer] good old `while` loops

---

# Generics

```scala
case class Box[A](value: A)
Box(1)
```

--

.section[Bad because]

```scala
13: iconst_1
14: invokestatic  #41                 // Method scala/runtime/BoxesRunTime.boxToInteger:(I)Ljava/lang/Integer;
17: invokespecial #45                 // Method $line37/$read$$iw$Box."<init>":(L$line37/$read$$iw;Ljava/lang/Object;)V
```

---

# Generics

.section[Prefer]

```scala
case class SpBox[@specialized A](value: A)
SpBox(1)
```

```scala
13: iconst_1
14: invokespecial #41                 // Method $line39/$read$$iw$SpBox$mcI$sp."<init>":(L$line39/$read$$iw;I)V
```

cf: https://scalac.io/specialized-generics-object-instantiation/

---

# Tuples

```scala
final case class Tuple2[
  @specialized(Int, Long, Double, Char, Boolean) +T1, 
  @specialized(Int, Long, Double, Char, Boolean) +T2
]
(_1: T1, _2: T2)
```

---

# Tuples


```scala
(1, 1)
```

--

.section[Good because]

```scala
scala> (1, 1).getClass
val res2: Class[_ <: (Int, Int)] = class scala.Tuple2$mcII$sp
```

---

# Tuples


```scala
(1, "1")
```

--

.section[Bad because]

```scala
scala> (1, "1").getClass
val res3: Class[_ <: (Int, String)] = class scala.Tuple2
```

---

# Tuples

.section[Prefer]

```scala
case class IntAndString(i: Int, s: String)
```

---

# Value class

```scala
case class Id(value: Long) extends AnyVal
```

Goal

- typesafe identifier
- without the runtime overhead of having an object around a `long`

http://ktoso.github.io/scala-types-of-types/#value-class

---

# Value class

When Allocation Is Necessary

https://docs.scala-lang.org/overviews/core/value-classes.html#when-allocation-is-necessary

---

# Equality

```scala
case class Id(value: Long) extends AnyVal
id1 === id2
```

--

.section[Bad because] Boxing

---

# Equality

.section[Prefer]

```scala
Eq.eqv(id1, id2)
```

Because

```scala
trait Eq[@sp A] extends Any with Serializable { self =>
```


---

# Value class and generics

```scala
case class Foo(id: Id)
case class Id(value: Long) extends Anyval

ids.contains(foo.id)
```

--

.section[Bad because] instantiates `Id` at each call

---

# Value class and generics

.section[Prefer]

```scala
case class Foo(id: Id)
case class Id(value: Long)
```

---

# Value class and `hashCode`

```scala
case class Id(value: Int) extends AnyVal
case class Key(id1: Id, id2: Id)

key.hashCode()
```

--

.section[Bad because] instantiates 2 `Id` and 2 `Long`

---

# Value class and `hashCode`

.section[Prefer]

```scala
case class Id(value: Int) extends AnyVal
case class Key(id1: Id, id2: Id) {
  override def hashCode(): Int = (id1.value | id2.value << 32).##
}
```

---

# Collections

## List

```scala
val list : List[Int] = ???
list.size
```

--

.section[Bad because] O(n)

---

# Collections

## List

```scala
val list : List[Int] = ???
list.contains
```

--

.section[Bad because] O(n)

---

# Collections

## Set

```scala
val ids : HashSet[Int] = ???
ids.contains(1)
```

--

.section[Bad because] `HashSet[Int]` is slow

---

# Collections

## Set

.section[Prefer] `BitSet` when ids are dense and small

---

# Collections

## Map

```scala
val cache : Map[DeviceType, NonEmptyList[PortfolioItem]] = ???
cache.get(Mobile)
```

--

.section[Bad because] `HashMap.get` is slow

---

# Collections

## Map

.section[Prefer] Array when ids are small and dense

```scala
val cache : Array[Option[NonEmptyList[PortfolioItem]]] = ???
cache(Mobile.value)
```

lookup is faster and it avoids allocating an `Option`

---

# Collections

## Map

```scala
val buffer : Map[Int, Double] = ???
```

--

.section[Bad because] generic collections are slow and memory unefficient

---

# Collections

## Map

.section[Prefer] primitive collections like [fastutil](http://fastutil.di.unimi.it/)

---

# Thanks

    </textarea>
    <script src="js/remark.js" type="text/javascript">
    </script>
    <script type="text/javascript">
        var slideshow = remark.create({
        highlightStyle: 'solarized-dark'
      });
    </script>
  </body>
</html>
